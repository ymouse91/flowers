<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flowers ‚Äî Solo (iPad)</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#101418">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
  <style>
    :root{
      --bg:#101418;
      --panel:#161b22;
      --ink:#e9eef5;
      --muted:#8aa0b6;
      --good:#70e000;
      --bad:#ff6b6b;
      --red:#e74c3c;
      --yellow:#f1c40f;
      --blue:#3498db;
      --green:#2ecc71;
      --purple:#a66efe;
      --cell: min(6vh, 6vw);
      --radius:18px;
    }
    html,body{height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0}
    .app{min-height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:8px;padding:env(safe-area-inset-top) 12px calc(12px + env(safe-area-inset-bottom));}
    header{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:10px}
    h1{margin:0;font-size:clamp(16px,3.6vw,28px);text-align:center;letter-spacing:.5px}
    .controls-left,.controls-right{display:flex;gap:8px;align-items:center}
    .pill{background:var(--panel);padding:8px 12px;border-radius:999px;display:flex;gap:10px;align-items:center;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:700;color:#0b0f14;background:#e9eef5;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .btn.ghost{background:transparent;color:var(--ink);border:1px solid #2a3545}
    .toggle{display:flex;align-items:center;gap:8px}
    .toggle input{transform:scale(1.2)}
    main{display:grid;grid-template-columns:320px 1fr;gap:12px}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }
    .left{display:grid;gap:12px}
    .panel{background:var(--panel);border-radius:var(--radius);padding:12px;box-shadow:0 12px 28px rgba(0,0,0,.35)}
    .stacks{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .stack{position:relative;display:grid;place-items:center;border-radius:12px;padding:10px;background:linear-gradient(180deg,#1a222f,#121720);min-height:120px;cursor:pointer}
    .count{position:absolute;top:8px;right:10px;background:#0e1420;border:1px solid #2a3545;border-radius:999px;padding:6px 12px;font-weight:800;font-size:clamp(16px,3.2vw,28px);color:var(--ink);box-shadow:0 2px 8px rgba(0,0,0,.35)}
    .faceup{display:grid;gap:8px}
    .hand{display:grid;gap:10px}
    .hand .slot{min-height:calc(var(--cell) * 1.4);border:2px dashed #2a3545;border-radius:12px;display:grid;place-items:center}
    .help{font-size:13px;color:var(--muted);text-align:center}
    .scorebox{display:grid;gap:8px}
    .row{display:flex;justify-content:space-between;align-items:center;font-size:18px}
    .row .v{font-weight:700}
    .row.good .v{color:var(--good)}
    .row.bad .v{color:var(--bad)}
    .garden-wrap{display:grid;gap:8px}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .garden{user-select:none;touch-action:manipulation;display:grid;grid-template-columns:repeat(var(--cols), var(--cell));grid-auto-rows:var(--cell);background:linear-gradient(180deg,#0f141d,#0b0f16);border-radius:18px;padding:8px;gap:6px;justify-content:center;align-content:center}
    .cell{width:var(--cell);height:var(--cell);border-radius:12px;background:#0c1119;border:1px solid #1b2639;position:relative;display:grid;place-items:center;overflow:hidden}
    .cell.hit{outline:3px solid #2b82ff;outline-offset:-3px}
    /* Himmenn√§ tyhjennysruudut pelin lopussa */
    .cell.dim{filter:brightness(0.55) saturate(0.75); transition:filter .2s ease;}

    .card{--c:#888;--t:#111;position:relative;width:calc(var(--cell) * 0.94);height:calc(var(--cell) * 1.28);border-radius:14px;
      background:radial-gradient(100% 60% at 30% 20%, rgba(255,255,255,.15), transparent 55%),
      repeating-conic-gradient(from .25turn, rgba(255,255,255,.08) 0 10deg, transparent 10deg 20deg), var(--c);
      border:2px solid rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 24px rgba(0,0,0,.45);}
    .card .num{font-size:calc(var(--cell) * 0.8);font-weight:900;color:rgba(255,255,255,.96);text-shadow:0 2px 0 rgba(0,0,0,.35);line-height:1;transform:translateY(-6%);} 
    .garden .card .num { transform: translateY(-25%); }

    /* UUSI: v√§rillinen perhosbadge (nelj√§ v√§ri√§) */
    .butterfly-badge{
      position:absolute; right:8px; top:8px;
      width:calc(var(--cell)*0.36); height:calc(var(--cell)*0.36);
      border-radius:999px; display:grid; place-items:center;
      font-size:calc(var(--cell)*0.22); font-weight:900;
      color:#fff; box-shadow:0 1px 3px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.15);
      text-shadow:0 1px 0 rgba(0,0,0,.35);
    }
    .bf-yellow{ background:var(--yellow); color:#101418; text-shadow:none; }
    .bf-red{ background:var(--red); }
    .bf-blue{ background:var(--blue); }
    .bf-green{ background:var(--green); }

    .ghost{opacity:.9}
    .stacked::after{content:"";position:absolute;inset:auto 6px 6px auto;width:calc(var(--cell)*0.7);height:calc(var(--cell)*0.95);border-radius:12px;background:rgba(0,0,0,.25);transform:translate(6px,6px)}
    .start{--c:linear-gradient(135deg, #7b5cff, #a66efe);}
    .start .num{font-size:calc(var(--cell) * 0.45)}
    .c-red   { --c:linear-gradient(135deg,#ffad98,var(--red)); }
    .c-yellow{ --c:linear-gradient(135deg,#ffeaa7,var(--yellow)); }
    .c-blue  { --c:linear-gradient(135deg,#a3d5ff,var(--blue)); }
    .c-green { --c:linear-gradient(135deg,#a6f4c5,var(--green)); }
    footer{display:flex;justify-content:center;gap:12px;align-items:center;color:var(--muted);font-size:12px}
    a{color:#7ec8ff}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="controls-left">
        <div class="pill">
          <button id="newBtn" class="btn">Uusi peli</button>
          <label class="toggle" title="Kes√§-variantti: vain purppuran viereiset kent√§t pisteytt√§v√§t">
            <input id="summerChk" type="checkbox"/>
            <span>Kes√§-variantti</span>
          </label>
        </div>
      </div>
      <h1>üå∏ Flowers ‚Äî Solo</h1>
      <div class="controls-right">
        <div class="pill">
          <span id="status">Klikkaa pinoa nostaaksesi.</span>
        </div>
      </div>
    </header>

    <main>
      <section class="left">
        <div class="panel stacks">
          <div class="stack" id="upStackBox" role="button" title="Klikkaa nostaaksesi n√§kyv√§st√§ pinosta">
            <div class="count" id="upCount">0</div>
            <div id="upTop" class="faceup"></div>
          </div>
          <div class="stack" id="downStackBox" role="button" title="Klikkaa nostaaksesi pime√§st√§ pinosta">
            <div class="count" id="downCount">0</div>
            <div id="downBack" class="card ghost" aria-hidden="true"></div>
          </div>
        </div>

        <div class="panel hand">
          <div class="slot" id="handSlot"><span class="help">Nostettu kortti n√§kyy t√§ss√§. Pelaa kortti: <b>viereen</b> (tyhj√§ ruutu jonkin kortin vieress√§) tai <b>p√§√§lle</b> (mink√§ tahansa ruudun p√§√§lle).</span></div>
        </div>

        <div>
          <button id="undoBtn" class="btn ghost" title="Peru viimeisin siirto">Peru</button>
        </div>

        <div class="panel scorebox" id="scoreBox">
          <div class="row"><span>Tyhjennyksi√§ (‚àí1/kortti)</span><span class="v bad" id="vPen">0</span></div>
          <div class="row"><span>V√§rikent√§t (1/kortti)</span><span class="v good" id="vFields">0</span></div>
          <div class="row"><span>Perhoset (+1/kpl)</span><span class="v good" id="vButter">0</span></div>
          <div class="row"><span><b>Yhteens√§</b></span><span class="v" id="vTotal">0</span></div>
          <div class="row"><span>Taso</span><span class="v" id="vRank">‚Äì</span></div>
        </div>
      </section>

      <section class="garden-wrap">
        <div class="toolbar">
          <span class="help">SOLO: 2 pinoa (toinen n√§kyv√§). Pelaa nostettu kortti, sitten n√§kyv√§n pinon p√§√§llimm√§inen palaa ja alta k√§√§ntyy uusi. Peli p√§√§ttyy kun jompikumpi pinoista loppuu.</span>
        </div>
        <div id="garden" class="garden" style="--cols:13"></div>
      </section>
    </main>

    <footer>
      <span>Flowers ¬© 2023 Actarus √©ditions ‚Äî suunnittelu: Paul-Henri Argiot. T√§m√§ on ep√§virallinen sooloversio iPadille.</span>
    </footer>
  </div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js', { scope: './' })
      .catch(err => console.error('SW register failed', err));
  });
}
</script>

<script>
(() => {
  const COLORS = ["yellow","red","blue","green"];
  const GRID = 13;
  const STACK_SIZE_SOLO = 40;

  let state = {
    summer: false,
    grid: null,
    startCell: null,
    faceUp: [],
    faceDown: [],
    upTop: null,
    hand: null,
    burned: [],
    history: [],
    finished: false,
    removedCount: 0,
    lastScore: {pen:0,fields:0,butter:0,total:0},
    variantLocked: false,
    lastDrawFrom: null,
    penaltyCells: new Set()
  };

  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function randInt(n){ return Math.floor(Math.random()*n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]] } return a }

  function buildDeck(){
    const deck = [];
    const make = (color, value, n) => { for(let i=0;i<n;i++){ deck.push({id:`${color}-${value}-${i}-${Math.random().toString(36).slice(2,7)}`, color, value, butterfly:null}); } };
    for(const c of COLORS){
      make(c,1,3); make(c,2,6); make(c,3,8); make(c,4,10);
    }
    // Perhoset: jokaiselle v√§rille 3 kpl, jotka "targetoivat" muita v√§rej√§
    for(const c of COLORS){
      const fourIdx = deck.map((k,idx)=>[k,idx]).filter(([k])=>k.color===c && k.value===4).map(([_,idx])=>idx);
      shuffle(fourIdx);
      const targets = COLORS.filter(x=>x!==c); // kolme muuta v√§ri√§
      for(let t=0;t<3;t++){
        const idx = fourIdx[t];
        deck[idx].butterfly = targets[t]; // -> tuloksena kaikki nelj√§ perhosv√§ri√§ esiintyv√§t pakassa
      }
    }
    return deck;
  }

  function emptyGrid(){ return Array.from({length:GRID}, ()=>Array.from({length:GRID}, ()=>[])); }
  function cellTop(r,c){ const st = state.grid[r]?.[c]; return st && st.length? st[st.length-1] : null; }
  function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID }
  const DIRS = [[1,0],[-1,0],[0,1],[0,-1]];
  function neighbors(r,c){ const out=[]; for(const [dr,dc] of DIRS){ const rr=r+dr, cc=c+dc; if(inBounds(rr,cc)) out.push([rr,cc]); } return out; }

  function pushHistory(){
    const snapshot = {
      summer: state.summer,
      grid: state.grid.map(row => row.map(st => st.slice())),
      startCell: state.startCell,
      faceUp: state.faceUp.slice(),
      faceDown: state.faceDown.slice(),
      upTop: state.upTop,
      hand: state.hand,
      burned: state.burned.slice(),
      finished: state.finished
    };
    state.history.push(JSON.stringify(snapshot));
    if (state.history.length > 40) state.history.shift();
  }
  function popHistory(){
    const s = state.history.pop(); if(!s) return; const snap = JSON.parse(s);
    state.summer=snap.summer; state.grid=snap.grid; state.startCell=snap.startCell;
    state.faceUp=snap.faceUp; state.faceDown=snap.faceDown; state.upTop=snap.upTop;
    state.hand=snap.hand; state.burned=snap.burned; state.finished=snap.finished;
    renderAll("Peruttu.");
  }

  function setup(){
    state.summer = document.getElementById('summerChk').checked;
    state.grid = emptyGrid();
    state.history = [];
    state.finished = false;
    state.hand = null;
    state.burned = [];
    state.lastDrawFrom = null;
    state.variantLocked = false;
    state.penaltyCells = new Set();
    document.getElementById('summerChk').disabled = false;

    let deck = buildDeck();
    shuffle(deck);

    const center = [Math.floor(GRID/2), Math.floor(GRID/2)];
    state.startCell = center;
    if(state.summer){
      state.grid[center[0]][center[1]] = [{id:"start", start:true}];
    } else {
      const startCard = deck.pop();
      state.grid[center[0]][center[1]] = [startCard];
    }

    const upTake = Math.min(STACK_SIZE_SOLO, deck.length);
    state.faceUp = deck.splice(deck.length - upTake, upTake);
    const downTake = Math.min(STACK_SIZE_SOLO, deck.length);
    state.faceDown = deck.splice(deck.length - downTake, downTake);
    state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;

    pushHistory();
    renderAll("Klikkaa pinoa nostaaksesi.");
  }

  function draw(from){
    if (!state.variantLocked) {
      state.variantLocked = true;
      document.getElementById('summerChk').disabled = true;
    }
    if(state.finished) return;
    if(state.hand){ status("Pelaa ensin k√§dess√§ oleva kortti."); return; }
    pushHistory();
    let card = null;
    if(from==='up'){
      if(!state.faceUp.length){ status("N√§kyv√§ pino on tyhj√§."); return; }
      card = state.faceUp.pop();
      state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;
    } else if(from==='down') {
      if(!state.faceDown.length){ status("Pime√§ pino on tyhj√§."); return; }
      card = state.faceDown.pop();
    }
    state.lastDrawFrom = from;
    state.hand = card;
    renderAll("Sijoita kortti viereen tai p√§√§lle.");
  }

  function canPlaceNextTo(r,c){
    if(cellTop(r,c)) return false;
    for(const [rr,cc] of neighbors(r,c)){
      const top = cellTop(rr,cc);
      if(top) return true;
    }
    return false;
  }

  function placeAt(r,c){
    if(!state.hand) return;
    const stack = state.grid[r][c];
    const canOnTop = stack && stack.length>0 && !(state.summer && stack[stack.length-1]?.start);
    const canNext = canPlaceNextTo(r,c);
    if(!(canOnTop || canNext)){
      flashCell(r,c);
      status("Sijoitus ei ole sallittu. Valitse tyhj√§ viereinen ruutu tai pelaa p√§√§lle.");
      return;
    }
    state.grid[r][c].push(state.hand);
    state.hand = null;

    // Polta n√§kyv√§st√§ nostettaessa
    if (state.lastDrawFrom === 'up' && state.faceUp.length) {
      const burned = state.faceUp.pop();
      state.burned.push(burned);
      state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;
    }
    state.lastDrawFrom = null;

    if(state.faceUp.length===0 || state.faceDown.length===0){
      state.finished = true;
      renderAll("Peli p√§√§ttyi: pino tyhjeni. Pisteet alla.");
      autoScore();
      return;
    }
    renderAll("Klikkaa pinoa nostaaksesi.");
  }

  function flashCell(r,c){
    const idx = r*GRID + c;
    const el = document.querySelectorAll('.cell')[idx];
    if(!el) return;
    el.classList.add('hit');
    setTimeout(()=>el.classList.remove('hit'), 350);
  }

  function computeScore(){
  const g = state.grid.map(row => row.map(st => st.slice()));
  const topMap = new Map();
  for (let r=0; r<GRID; r++) for (let c=0; c<GRID; c++) {
    const top = g[r][c].length ? g[r][c][g[r][c].length-1] : null;
    topMap.set(`${r},${c}`, top);
  }

  // K√§yt√§ aina vain ortogonaalisia suuntia (EI diagonaaleja)
  const ORTHO = [[1,0],[-1,0],[0,1],[0,-1]];
  const inB = (r,c) => r>=0 && r<GRID && c>=0 && c<GRID;

  // 1) TYHJENNYS: N-komponentit vain numeron perusteella, ortogonaalinen yhteys
  const toRemove = new Set();
  for (const val of [1,2,3,4]) {
    const seen = new Set();
    for (let r=0; r<GRID; r++) for (let c=0; c<GRID; c++) {
      const t = topMap.get(`${r},${c}`); const key = `${r},${c}`;
      if (!t || t.start) continue;
      if (t.value !== val || seen.has(key)) continue;

      // BFS numerolla 'val' (ORTOGONAALINEN)
      const comp = [];
      const q = [[r,c]];
      seen.add(key);
      while (q.length) {
        const [rr,cc] = q.shift();
        comp.push([rr,cc]);
        for (const [dr,dc] of ORTHO) {
          const nr = rr+dr, nc = cc+dc;
          if (!inB(nr,nc)) continue;
          const t2 = topMap.get(`${nr},${nc}`);
          const k2 = `${nr},${nc}`;
          if (!t2 || t2.start) continue;
          if (t2.value === val && !seen.has(k2)) { seen.add(k2); q.push([nr,nc]); }
        }
      }

      const ok = (val === 1 ? comp.length === 1 : comp.length === val);
      if (!ok) for (const pos of comp) toRemove.add(pos.join(','));
    }
  }

  // ‚àí1 / kortti ruudun pinossa; tyhjenn√§ ennen plussia
  let penalties = 0;
  for (const key of toRemove) {
    const [r,c] = key.split(',').map(Number);
    penalties += g[r][c].length;
    g[r][c] = [];
    topMap.set(key, null);
  }

  // 2) V√ÑRIKENT√ÑT: ortogonaalinen yhteys, ‚â•5 ‚Üí 1 p / kortti
  let fieldPoints = 0;
  const seenF = new Set();
  for (let r=0; r<GRID; r++) for (let c=0; c<GRID; c++) {
    const t = topMap.get(`${r},${c}`); const key = `${r},${c}`;
    if (!t || t.start || seenF.has(key)) continue;
    const color = t.color;

    const comp = []; const q = [[r,c]]; seenF.add(key);
    while (q.length) {
      const [rr,cc] = q.shift(); comp.push([rr,cc]);
      for (const [dr,dc] of ORTHO) {
        const nr = rr+dr, nc = cc+dc;
        if (!inB(nr,nc)) continue;
        const t2 = topMap.get(`${nr},${nc}`); const k2 = `${nr},${nc}`;
        if (!t2 || t2.start) continue;
        if (t2.color === color && !seenF.has(k2)) { seenF.add(k2); q.push([nr,nc]); }
      }
    }

    if (comp.length >= 5) {
      if (state.summer) {
        const [sr,sc] = state.startCell;
        const touches = comp.some(([rr,cc]) => Math.abs(rr-sr)+Math.abs(cc-sc) === 1);
        if (touches) fieldPoints += comp.length;
      } else {
        fieldPoints += comp.length;
      }
    }
  }

  // 3) PERHOSET: topissa + ortogonaalinen naapuri samaa kohdev√§ri√§
  let butter = 0;
  for (let r=0; r<GRID; r++) for (let c=0; c<GRID; c++) {
    const t = topMap.get(`${r},${c}`);
    if (!t || t.start || !t.butterfly) continue;
    for (const [dr,dc] of ORTHO) {
      const nr = r+dr, nc = c+dc;
      if (!inB(nr,nc)) continue;
      const nb = topMap.get(`${nr},${nc}`);
      if (nb && !nb.start && nb.color === t.butterfly) { butter++; break; }
    }
  }

  const total = fieldPoints + butter - penalties;
  return { penalties, fieldPoints, butter, total, penaltyCells: Array.from(toRemove) };
}


  function rank(total){
    if(total<=10) return "Aloittelija";
    if(total<=17) return "Oppipoika";
    if(total<=25) return "Ekspertti";
    return "Mestari";
  }

  function autoScore(){
    const s = computeScore();
    state.lastScore = {pen:s.penalties, fields:s.fieldPoints, butter:s.butter, total:s.total};
    state.removedCount = s.penalties;
    state.penaltyCells = new Set(s.penaltyCells);
    document.getElementById('vPen').textContent = s.penalties;
    document.getElementById('vFields').textContent = s.fieldPoints;
    document.getElementById('vButter').textContent = s.butter;
    document.getElementById('vTotal').textContent = s.total;
    document.getElementById('vRank').textContent = rank(s.total);
  }

  function status(txt){ document.getElementById('status').textContent = txt; }

  function renderAll(stat){
    if(stat) status(stat);
    document.getElementById('upCount').textContent = state.faceUp.length;
    document.getElementById('downCount').textContent = state.faceDown.length;

    const upTopEl = document.getElementById('upTop');
    upTopEl.innerHTML = '';
    if(state.upTop){ upTopEl.appendChild(renderCard(state.upTop)); }

    const handSlot = document.getElementById('handSlot');
    handSlot.innerHTML = '';
    if(state.hand){ handSlot.appendChild(renderCard(state.hand)); }
    autoScore();
    renderGarden();


    document.getElementById('undoBtn').disabled = state.history.length===0;
  }

  function renderCard(card){
    const el = document.createElement('div');
    if(card.start){
      el.className = 'card start';
      el.innerHTML = `<div class="num">START</div>`;
      return el;
    }
    el.className = `card c-${card.color}`;
    el.innerHTML = `
      <div class="num">${card.value}</div>
      ${card.butterfly? `<div class="butterfly-badge bf-${card.butterfly}" title="Perhonen (kohdev√§ri: ${card.butterfly})">ü¶ã</div>`:''}
    `;
    return el;
  }

  function renderGarden(){
    const root = document.getElementById('garden');
    root.innerHTML = '';
    for(let r=0;r<GRID;r++){
      for(let c=0;c<GRID;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r; cell.dataset.c = c;
        const stack = state.grid[r][c];
        const top = stack.length? stack[stack.length-1]: null;
        if(top){
          const cardEl = renderCard(top);
          if(stack.length>1) cardEl.classList.add('stacked');
          cell.appendChild(cardEl);
        }
        if(state.hand){
          if(!top && canPlaceNextTo(r,c)) cell.style.outline = '2px dashed #2b82ff';
          if(top && !(state.summer && top.start)) cell.style.boxShadow = 'inset 0 0 0 2px #4ade80';
        }
        if (state.finished && state.penaltyCells.has(`${r},${c}`)) {
          cell.classList.add('dim');
        }
        cell.addEventListener('click', onCellClick);
        root.appendChild(cell);
      }
    }
  }

  function onCellClick(ev){
    const r = +ev.currentTarget.dataset.r;
    const c = +ev.currentTarget.dataset.c;
    if(!state.hand){ return; }
    placeAt(r,c);
  }

  // tapahtumat
  document.getElementById('newBtn').addEventListener('click', setup);
  document.getElementById('undoBtn').addEventListener('click', popHistory);
  document.getElementById('summerChk').addEventListener('change', setup);
  document.getElementById('upStackBox').onclick = ()=>draw('up');
  document.getElementById('downStackBox').onclick = ()=>draw('down');

  // init
  setup();
})();
</script>
</body>
</html>
