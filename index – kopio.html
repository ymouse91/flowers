<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flowers ‚Äî Solo (iPad)</title>
  <!-- PWA basics -->
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#101418">

<!-- iOS (Safari) -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

  <style>
    :root{
      --bg:#101418;
      --panel:#161b22;
      --ink:#e9eef5;
      --muted:#fb0c8;
      --good:#70e000;
      --bad:#ff6b6b;

      --red:#e74c3c;
      --yellow:#f1c40f;
      --blue:#3498db;
      --green:#2ecc71;
      --purple:#a66efe;

      --cell: min(6vh, 6vw); /* responsive square size for iPad */
      --radius:18px;
    }
    html,body{height:100%;background:var(--bg);color:var(--ink);font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;margin:0}
    .app{min-height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:8px;padding:env(safe-area-inset-top) 12px calc(12px + env(safe-area-inset-bottom));}

    header{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:10px}
    h1{margin:0;font-size:clamp(16px,3.6vw,28px);text-align:center;letter-spacing:.5px}
    .controls-left,.controls-right{display:flex;gap:8px;align-items:center}
    .pill{background:var(--panel);padding:8px 12px;border-radius:999px;display:flex;gap:10px;align-items:center;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:700;color:#0b0f14;background:#e9eef5;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .btn.ghost{background:transparent;color:var(--ink);border:1px solid #2a3545}
    .toggle{display:flex;align-items:center;gap:8px}
    .toggle input{transform:scale(1.2)}

    main{display:grid;grid-template-columns:320px 1fr;gap:12px}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }

    .left{display:grid;gap:12px}
    .panel{background:var(--panel);border-radius:var(--radius);padding:12px;box-shadow:0 12px 28px rgba(0,0,0,.35)}

    .stacks{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .stack{position:relative;display:grid;place-items:center;border-radius:12px;padding:10px;background:linear-gradient(180deg,#1a222f,#121720);min-height:120px;cursor:pointer}
    .stack h3{margin:0 0 6px 0;font-size:14px;color:var(--muted);font-weight:600}
    .count{position:absolute;top:8px;right:10px;background:#0e1420;border:1px solid #2a3545;border-radius:999px;padding:6px 12px;font-weight:800;font-size:clamp(16px,3.2vw,28px);color:var(--ink);box-shadow:0 2px 8px rgba(0,0,0,.35)}
    .faceup{display:grid;gap:8px}

    .hand{display:grid;gap:10px}
    .hand .slot{min-height:calc(var(--cell) * 1.4);border:2px dashed #2a3545;border-radius:12px;display:grid;place-items:center}
    .help{font-size:13px;color:var(--muted);text-align:center}

    .scorebox{display:grid;gap:8px}
    .row{display:flex;justify-content:space-between;align-items:center;font-size:18px}
    .row .v{font-weight:700}
    .row.good .v{color:var(--good)}
    .row.bad .v{color:var(--bad)}

    .garden-wrap{display:grid;gap:8px}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}

    .garden{user-select:none;touch-action:manipulation;display:grid;grid-template-columns:repeat(var(--cols), var(--cell));grid-auto-rows:var(--cell);background:linear-gradient(180deg,#0f141d,#0b0f16);border-radius:18px;padding:8px;gap:6px;justify-content:center;align-content:center}

    .cell{width:var(--cell);height:var(--cell);border-radius:12px;background:#0c1119;border:1px solid #1b2639;position:relative;display:grid;place-items:center;overflow:hidden}
    .cell.hit{outline:3px solid #2b82ff;outline-offset:-3px}

    .card{--c:#888;--t:#111;position:relative;width:calc(var(--cell) * 0.94);height:calc(var(--cell) * 1.28);border-radius:14px;background:radial-gradient(100% 60% at 30% 20%, rgba(255,255,255,.15), transparent 55%),
      repeating-conic-gradient(from .25turn, rgba(255,255,255,.08) 0 10deg, transparent 10deg 20deg), var(--c);
      border:2px solid rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 24px rgba(0,0,0,.45);
    }
    .card .num{font-size:calc(var(--cell) * 0.8);font-weight:900;color:rgba(255,255,255,.96);text-shadow:0 2px 0 rgba(0,0,0,.35);line-height:1;transform:translateY(-6%);} 
    .garden .card .num { transform: translateY(-25%); }

    .butterfly{position:absolute;right:8px;top:8px;font-size:calc(var(--cell) * 0.28);filter:drop-shadow(0 0 2px rgba(0,0,0,.6))}

    .ghost{opacity:.9}
    .stacked::after{content:"";position:absolute;inset:auto 6px 6px auto;width:calc(var(--cell)*0.7);height:calc(var(--cell)*0.95);border-radius:12px;background:rgba(0,0,0,.25);transform:translate(6px,6px)}

    .start{--c:linear-gradient(135deg, #7b5cff, #a66efe);}
    .start .num{font-size:calc(var(--cell) * 0.45)}

    .c-red   { --c:linear-gradient(135deg,#ffad98,var(--red)); }
    .c-yellow{ --c:linear-gradient(135deg,#ffeaa7,var(--yellow)); }
    .c-blue  { --c:linear-gradient(135deg,#a3d5ff,var(--blue)); }
    .c-green { --c:linear-gradient(135deg,#a6f4c5,var(--green)); }

    footer{display:flex;justify-content:center;gap:12px;align-items:center;color:var(--muted);font-size:12px}
    a{color:#7ec8ff}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="controls-left">
        <div class="pill">
          <button id="newBtn" class="btn">Uusi peli</button>
          <label class="toggle" title="Kes√§-variantti: vain purppuran viereiset kent√§t pisteytt√§v√§t">
            <input id="summerChk" type="checkbox"/>
            <span>Kes√§-variantti</span>
          </label>
        </div>
      </div>

      <h1>üå∏ Flowers ‚Äî Solo</h1>

      <div class="controls-right">
        <div class="pill">
          <span id="status">Klikkaa pinoa nostaaksesi.</span>
        </div>
      </div>
    </header>

    <main>
      <section class="left">
        <div class="panel stacks">
          <div class="stack" id="upStackBox" role="button" title="Klikkaa nostaaksesi n√§kyv√§st√§ pinosta">
            
            <div class="count" id="upCount">0</div>
            <div id="upTop" class="faceup"></div>
			<!--<h3>N√ÑKYV√Ñ PINO</h3>-->
          </div>
          <div class="stack" id="downStackBox" role="button" title="Klikkaa nostaaksesi pime√§st√§ pinosta">
            <!--<h3>PIME√Ñ PINO</h3>-->
            <div class="count" id="downCount">0</div>
            <div id="downBack" class="card ghost" aria-hidden="true"></div>
          </div>
        </div>

        <div class="panel hand">
          <div class="slot" id="handSlot"><span class="help">Nostettu kortti n√§kyy t√§ss√§. Pelaa kortti: <b>viereen</b> (tyhj√§ ruutu jonkin kortin vieress√§) tai <b>p√§√§lle</b> (mink√§ tahansa ruudun p√§√§lle).</span></div>
        </div>

        <div>
          <button id="undoBtn" class="btn ghost" title="Peru viimeisin siirto">Peru</button>
        </div>

        <div class="panel scorebox" id="scoreBox">
          <div class="row"><span>Tyhjennyksi√§ (‚àí1/kortti)</span><span class="v bad" id="vPen">0</span></div>
          <div class="row"><span>V√§rikent√§t (1/kortti)</span><span class="v good" id="vFields">0</span></div>
          <div class="row"><span>Perhoset (+1/kpl)</span><span class="v good" id="vButter">0</span></div>
          <div class="row"><span><b>Yhteens√§</b></span><span class="v" id="vTotal">0</span></div>
          <div class="row"><span>Taso</span><span class="v" id="vRank">‚Äì</span></div>
        </div>
      </section>

      <section class="garden-wrap">
        <div class="toolbar">
          <span class="help">SOLO: 2 pinoa (toinen n√§kyv√§). Pelaa nostettu kortti, sitten n√§kyv√§n pinon p√§√§llimm√§inen palaa ja alta k√§√§ntyy uusi. Peli p√§√§ttyy kun jompikumpi pinoista loppuu.</span>
        </div>
        <div id="garden" class="garden" style="--cols:13"></div>
      </section>
    </main>

    <footer>
      <span>Flowers ¬© 2023 Actarus √©ditions ‚Äî suunnittelu: Paul‚ÄëHenri Argiot. T√§m√§ on ep√§virallinen sooloversio iPadille.</span>
    </footer>
  </div>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js', { scope: './' })
      .catch(err => console.error('SW register failed', err));
  });
}
</script>

<script>
(() => {
  const COLORS = ["yellow","red","blue","green"];
  const COLOR_HEX = { yellow: getCSS('--yellow'), red:getCSS('--red'), blue:getCSS('--blue'), green:getCSS('--green') };
  const GRID = 13;
  const STACK_SIZE_SOLO = 40;

  let state = {
    summer: false,
    grid: null,
    startCell: null,
    faceUp: [],
    faceDown: [],
    upTop: null,
    hand: null,
    burned: [],
    history: [],
    finished: false,
    removedCount: 0,
    lastScore: {pen:0,fields:0,butter:0,total:0},
	variantLocked: false,
	lastDrawFrom: null          // <- LIS√Ñ√Ñ T√ÑM√Ñ
  };

  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function randInt(n){ return Math.floor(Math.random()*n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]] } return a }

  function buildDeck(){
    const deck = [];
    const make = (color, value, n) => { for(let i=0;i<n;i++){ deck.push({id:`${color}-${value}-${i}-${Math.random().toString(36).slice(2,7)}`, color, value, butterfly:null}); } };
    for(const c of COLORS){
      make(c,1,3); make(c,2,6); make(c,3,8); make(c,4,10);
    }
    for(const c of COLORS){
      const fourIdx = deck.map((k,idx)=>[k,idx]).filter(([k])=>k.color===c && k.value===4).map(([_,idx])=>idx);
      shuffle(fourIdx);
      const targets = COLORS.filter(x=>x!==c);
      for(let t=0;t<3;t++){
        const idx = fourIdx[t];
        deck[idx].butterfly = targets[t];
      }
    }
    return deck;
  }

  function emptyGrid(){ return Array.from({length:GRID}, ()=>Array.from({length:GRID}, ()=>[])); }
  function cellTop(r,c){ const st = state.grid[r]?.[c]; return st && st.length? st[st.length-1] : null; }
  function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID }
  const DIRS = [[1,0],[-1,0],[0,1],[0,-1]];
  function neighbors(r,c){ const out=[]; for(const [dr,dc] of DIRS){ const rr=r+dr, cc=c+dc; if(inBounds(rr,cc)) out.push([rr,cc]); } return out; }

  function pushHistory(){
    const snapshot = {
      summer: state.summer,
      grid: state.grid.map(row => row.map(st => st.slice())),
      startCell: state.startCell,
      faceUp: state.faceUp.slice(),
      faceDown: state.faceDown.slice(),
      upTop: state.upTop,
      hand: state.hand,
      burned: state.burned.slice(),
      finished: state.finished
    };
    state.history.push(JSON.stringify(snapshot));
    if (state.history.length > 40) state.history.shift();
  }
  function popHistory(){
    const s = state.history.pop(); if(!s) return; const snap = JSON.parse(s);
    state.summer=snap.summer; state.grid=snap.grid; state.startCell=snap.startCell;
    state.faceUp=snap.faceUp; state.faceDown=snap.faceDown; state.upTop=snap.upTop;
    state.hand=snap.hand; state.burned=snap.burned; state.finished=snap.finished;
    renderAll("Peruttu.");
  }

  function setup(){
    state.summer = document.getElementById('summerChk').checked;
    state.grid = emptyGrid();
    state.history = [];
    state.finished = false;
    state.hand = null;
    state.burned = [];
    state.lastDrawFrom = null;    // <- LIS√Ñ√Ñ T√ÑM√Ñ
	state.variantLocked = false;
    document.getElementById('summerChk').disabled = false;

    let deck = buildDeck();
    shuffle(deck);

    const center = [Math.floor(GRID/2), Math.floor(GRID/2)];
    state.startCell = center;
    if(state.summer){
      state.grid[center[0]][center[1]] = [{id:"start", start:true}];
    } else {
      const startCard = deck.pop();
      state.grid[center[0]][center[1]] = [startCard];
    }

    const upTake = Math.min(STACK_SIZE_SOLO, deck.length);
    state.faceUp = deck.splice(deck.length - upTake, upTake);
    const downTake = Math.min(STACK_SIZE_SOLO, deck.length);
    state.faceDown = deck.splice(deck.length - downTake, downTake);

    state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;

    pushHistory();
    renderAll("Klikkaa pinoa nostaaksesi.");
  }

  function draw(from){
  
    if (!state.variantLocked) {
    state.variantLocked = true;
    document.getElementById('summerChk').disabled = true; // est√§√§ vaihdon koko pelin ajaksi
    }
    if(state.finished) return;
    if(state.hand){ status("Pelaa ensin k√§dess√§ oleva kortti."); return; }
    pushHistory();
    let card = null;
    if(from==='up'){
      if(!state.faceUp.length){ status("N√§kyv√§ pino on tyhj√§."); return; }
      card = state.faceUp.pop();
      state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;
    } else if(from==='down') {
      if(!state.faceDown.length){ status("Pime√§ pino on tyhj√§."); return; }
      card = state.faceDown.pop();
      // HUOM: ei kosketa n√§kyv√§√§n pinoon nostaessa pime√§st√§
    }
	state.lastDrawFrom = from;    // <- LIS√Ñ√Ñ T√ÑM√Ñ
    state.hand = card;
    renderAll("Sijoita kortti viereen tai p√§√§lle.");
  }

  function canPlaceNextTo(r,c){
    if(cellTop(r,c)) return false;
    for(const [rr,cc] of neighbors(r,c)){
      const top = cellTop(rr,cc);
      if(top) return true;
    }
    return false;
  }

  function placeAt(r,c){
    if(!state.hand) return;
    const stack = state.grid[r][c];
    const canOnTop = stack && stack.length>0 && !(state.summer && stack[stack.length-1]?.start);
    const canNext = canPlaceNextTo(r,c);
    if(!(canOnTop || canNext)){
      flashCell(r,c);
      status("Sijoitus ei ole sallittu. Valitse tyhj√§ viereinen ruutu tai pelaa p√§√§lle.");
      return;
    }
    state.grid[r][c].push(state.hand);
    state.hand = null;

    // SOLO: polta n√§kyv√§n pinon p√§√§llimm√§inen vasta kun kortti on pelattu
// Polta VAIN, jos nosto tehtiin n√§kyv√§st√§ pinosta
if (state.lastDrawFrom === 'up' && state.faceUp.length) {
  const burned = state.faceUp.pop();
  state.burned.push(burned);
  state.upTop = state.faceUp.length ? state.faceUp[state.faceUp.length-1] : null;
}
state.lastDrawFrom = null; // nollaa aina pelin j√§lkeen


    if(state.faceUp.length===0 || state.faceDown.length===0){
      state.finished = true;
      renderAll("Peli p√§√§ttyi: pino tyhjeni. Pisteet alla.");
      autoScore();
      return;
    }

    renderAll("Klikkaa pinoa nostaaksesi.");
  }

  function flashCell(r,c){
    const idx = r*GRID + c;
    const el = document.querySelectorAll('.cell')[idx];
    if(!el) return;
    el.classList.add('hit');
    setTimeout(()=>el.classList.remove('hit'), 350);
  }

  function computeScore(){
    const g = state.grid.map(row=>row.map(st=>st.slice()));

    const topMap = new Map();
    for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++){
      const top = g[r][c].length ? g[r][c][g[r][c].length-1] : null;
      topMap.set(`${r},${c}`, top);
    }

    const toRemove = new Set();
    for(const val of [1,2,3,4]){
      const seen = new Set();
      for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++){
        const top = topMap.get(`${r},${c}`);
        const key = `${r},${c}`;
        if(!top || top.start) continue;
        if(top.value!==val || seen.has(key)) continue;
        const comp = [];
        const q = [[r,c]]; seen.add(key);
        while(q.length){
          const [rr,cc] = q.shift();
          comp.push([rr,cc]);
          for(const [nr,nc] of neighbors(rr,cc)){
            const t2 = topMap.get(`${nr},${nc}`);
            const k2 = `${nr},${nc}`;
            if(!t2 || t2.start) continue;
            if(t2.value===val && !seen.has(k2)){
              seen.add(k2); q.push([nr,nc]);
            }
          }
        }
        const ok = (val===1? comp.length===1 : comp.length===val);
        if(!ok){ for(const pos of comp){ toRemove.add(pos.join(',')); } }
      }
    }

    let penalties = 0;
    if(toRemove.size){
      for(const key of toRemove){
        const [r,c] = key.split(',').map(Number);
        penalties += g[r][c].length;
        g[r][c] = [];
        topMap.set(key, null);
      }
    }

    let fieldPoints = 0;
    const seenF = new Set();
    for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++){
      const top = topMap.get(`${r},${c}`);
      const ky = `${r},${c}`;
      if(!top || top.start || seenF.has(ky)) continue;
      const color = top.color;
      const comp=[]; const q=[[r,c]]; seenF.add(ky);
      while(q.length){
        const [rr,cc] = q.shift(); comp.push([rr,cc]);
        for(const [nr,nc] of neighbors(rr,cc)){
          const t2 = topMap.get(`${nr},${nc}`);
          const k2 = `${nr},${nc}`;
          if(!t2 || t2.start) continue;
          if(t2.color===color && !seenF.has(k2)){ seenF.add(k2); q.push([nr,nc]); }
        }
      }
      if(comp.length>=5){
        if(state.summer){
          const [sr,sc] = state.startCell;
          const ok = comp.some(([rr,cc])=> (Math.abs(rr-sr)+Math.abs(cc-sc))===1 );
          if(ok) fieldPoints += comp.length;
        } else {
          fieldPoints += comp.length;
        }
      }
    }

    let butter = 0;
    for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++){
      const top = topMap.get(`${r},${c}`);
      if(!top || top.start || !top.butterfly) continue;
      const want = top.butterfly;
      const ok = neighbors(r,c).some(([rr,cc])=>{
        const t2 = topMap.get(`${rr},${cc}`);
        return t2 && !t2.start && t2.color===want;
      });
      if(ok) butter += 1;
    }

    const total = fieldPoints + butter - penalties;
    return { penalties, fieldPoints, butter, total };
  }

  function rank(total){
    if(total<=10) return "Aloittelija";
    if(total<=17) return "Oppipoika";
    if(total<=25) return "Ekspertti";
    return "Mestari";
  }

  function autoScore(){
    const s = computeScore();
    state.lastScore = {pen:s.penalties, fields:s.fieldPoints, butter:s.butter, total:s.total};
    state.removedCount = s.penalties;
    document.getElementById('vPen').textContent = s.penalties;
    document.getElementById('vFields').textContent = s.fieldPoints;
    document.getElementById('vButter').textContent = s.butter;
    document.getElementById('vTotal').textContent = s.total;
    document.getElementById('vRank').textContent = rank(s.total);
  }

  function status(txt){ document.getElementById('status').textContent = txt; }

  function renderAll(stat){
    if(stat) status(stat);
    document.getElementById('upCount').textContent = state.faceUp.length;
    document.getElementById('downCount').textContent = state.faceDown.length;

    const upTopEl = document.getElementById('upTop');
    upTopEl.innerHTML = '';
    if(state.upTop){ upTopEl.appendChild(renderCard(state.upTop)); }

    const handSlot = document.getElementById('handSlot');
    handSlot.innerHTML = '';
    if(state.hand){ handSlot.appendChild(renderCard(state.hand)); }

    renderGarden();
    autoScore();

    document.getElementById('undoBtn').disabled = state.history.length===0;
  }

  function renderCard(card){
    const el = document.createElement('div');
    if(card.start){
      el.className = 'card start';
      el.innerHTML = `<div class="num">START</div>`;
      return el;
    }
    el.className = `card c-${card.color}`;
    const v = card.value;
    el.innerHTML = `
      <div class="num">${v}</div>
      ${card.butterfly? `<div class="butterfly" title="Perhonen: ${card.butterfly}">ü¶ã</div>`:''}
    `;
    return el;
  }

  function renderGarden(){
    const root = document.getElementById('garden');
    root.innerHTML = '';
    for(let r=0;r<GRID;r++){
      for(let c=0;c<GRID;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r; cell.dataset.c = c;
        const stack = state.grid[r][c];
        const top = stack.length? stack[stack.length-1]: null;
        if(top){
          const cardEl = renderCard(top);
          if(stack.length>1) cardEl.classList.add('stacked');
          cell.appendChild(cardEl);
        }

        if(state.hand){
          if(!top && canPlaceNextTo(r,c)) cell.style.outline = '2px dashed #2b82ff';
          if(top && !(state.summer && top.start)) cell.style.boxShadow = 'inset 0 0 0 2px #4ade80';
        }

        cell.addEventListener('click', onCellClick);
        root.appendChild(cell);
      }
    }
  }

  function onCellClick(ev){
    const r = +ev.currentTarget.dataset.r;
    const c = +ev.currentTarget.dataset.c;
    if(!state.hand){ return; }
    placeAt(r,c);
  }

  // tapahtumat
  document.getElementById('newBtn').addEventListener('click', setup);
  document.getElementById('undoBtn').addEventListener('click', popHistory);
  document.getElementById('summerChk').addEventListener('change', setup);
  document.getElementById('upStackBox').onclick = ()=>draw('up');
  document.getElementById('downStackBox').onclick = ()=>draw('down');

  // init
  setup();
})();
</script>
</body>
</html>
